# -*- coding: utf-8 -*-
"""DiabetesPredection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V0Y-Q3rEFWadVEAxB85JiAiEXZFbBO1l

Importing Packages required
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn import svm
from sklearn.metrics import accuracy_score

df = pd.read_csv('diabetes.csv')

df.sample(7)

df.shape

df.info()

"""All values are present"""

df.describe()

"""## Defining function to give upper and lower bond for data"""

def IQR_limit(df,column):
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    return max(0,Q1-1.5*IQR),Q3+1.5*IQR

"""1. Pregnancies"""

sns.boxplot(df['Pregnancies'])
plt.show()

IQR_limit(df,'Pregnancies')

df = df[df['Pregnancies'] <= 13]

"""2. Glucose	(50-200)"""

sns.boxplot(df['Glucose'])
plt.show()

IQR_limit(df,'Glucose')

df = df[df['Glucose']> 40]

"""3. BloodPressure (50-200) mmHG"""

sns.boxplot(df['BloodPressure'])
plt.show()

IQR_limit(df,'BloodPressure')

df = df[df['BloodPressure'] > 35]

"""4. SkinThickness (0 – 99) mm"""

sns.boxplot(df['SkinThickness'])
plt.show()

IQR_limit(df,'SkinThickness')

df = df[df['SkinThickness'] < 82]

df.info()

df.describe()

"""5. Insulin (0 – 900) μU/mL"""

sns.boxplot(df['Insulin'])
plt.show()

# Filter rows where Insulin is greater than 400
insulin_gt_400 = df[df['Insulin'] > 400]

# Display the filtered rows
insulin_gt_400

"""It is clearly visible that => higher the Insulin , Higher the chance of being Biabetes

Note : There are many values of many rows belonging to col 'SkinThickness',	'Insulin'	are '0', which is unusal .
Ideally SkinThickness is from (0.3 mm to 1 cm) , where Insulin for normal person is around 10 - upto 25

6. BMI (10 - 70)
"""

sns.boxplot(df['BMI'])
plt.show()

IQR_limit(df,'BMI')

df = df[df['BMI'] > 14]

df.describe()

"""7. DiabetesPedigreeFunction ( 0- 2.5) => In limit

# Scaling values
"""

scaler = StandardScaler()
X = df.drop(columns = 'Outcome', axis=1)
Y = df['Outcome']
X_scaled = scaler.fit_transform(X)
X = X_scaled

"""# Train-Test-Split"""

X_train, X_test, Y_train, Y_test = train_test_split(X,Y, test_size = 0.2, stratify=Y, random_state=2)

print(X.shape, X_train.shape, X_test.shape)

"""# Applying SVM Model on X_train and y_train"""

model = svm.SVC(kernel='linear')

model.fit(X_train, Y_train) # Training model

"""# Model Evaluation

1. Traing Data
"""

preadicted_Train = model.predict(X_train)

Score = accuracy_score(preadicted_Train, Y_train)

print('Accuracy Score of the training data : ', Score)

"""2. Test Data"""

preadicted_Test = model.predict(X_test)

Test_score = accuracy_score(preadicted_Test, Y_test)

print('Accuracy Score of the test data : ', Test_score)

"""# => Here for this small amount of data we got train score (=79%) and test score (=74%) . Also as there is very small difference between this score there is no overfitting of data.

# Creating function to predict
"""

def predict_diabetes(input_data):
  # Reshaping the input data to be a 2D array (required for prediction).
  input_data_as_numpy_array = np.asarray(input_data)
  input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

  # Standardize the input data using the same scaler used for training.
  Standardized_data = scaler.transform(input_data_reshaped)

  # Make a prediction
  prediction = model.predict(Standardized_data )
  print(prediction)

  if (prediction[0] == 0):
    print('The person is not diabetic')
  else:
    print('The person is diabetic')

"""Example"""

input_data = (5, 166, 72, 19, 175, 25.8, 0.587, 51)
predict_diabetes(input_data)

